# 操作系统

## 操作系统概述

* 并发和共享是操作系统的两个最基本的特征，二者互为存在条件
* 库函数是高级语言提供的，系统调用是操作系统提供的程序接口
* 当中断或异常发生时，运行用户态的 CPU 会立即进入核心态，这是通过硬件实现的
* 系统调用发生在用户态，在核心态处理执行
* OS 内核一般包括时钟管理，中断机制，原语，系统控制的数据结构及处理

## 进程管理

* PCB 是进程存在的唯一标志
* 线程是独立调度的基本单位，进程是拥有资源的基本单位，线程共享进程的逻辑地址空间，但有自己的栈空间
* 当进程被切换时，处理机状态信息（通用寄存器值，地址寄存器值，控制寄存器值，标志寄存器值，状态字）都必须存在相应的 PCB 中
* 线程包含 CPU 现场，可以独立运行程序，没有自己独立的地址空间，共享所属进程的空间
* C 语言编写的程序在使用内存时，一般分为三个段：
  * 正文段：二进制代码和常量，全局赋值变量
  * 数据堆段：动态分配的存储区
  * 数据栈段：临时使用的变量
* 进程调度的任务：
  * 保存处理机的现场信息
  * 按某种调度算法选取进程
  * 把处理器分配给进程
* **作业调度** 从外存的后备队列选择一批进入内存，为他们建立进程并送入就绪队列
* **中级调度** 将那些暂时不能运行的进程调到外存等待（挂起），唤醒具备运行条件的进程
* **进程调度** 从就绪队列中选出一个进程，把其状态改为运行状态，分配 CPU

* 系统吞吐量：单位时间内 CPU 完成作业的数量
* 周转时间 = 完成时间 - 提交时间，带权周转时间 = 周转时间 / 运行时间，二者都是针对作业的
* 引起进程调度的原因：
  * 当前运行进程结束
  * 当前运行进程进入阻塞状态
  * 执行完系统调用等系统进程返回用户进程
  * 剥夺调度方式中更高优先级的进程要用处理器
  * 分时系统中时间片用完
* 不能进行调度的情况
  * 处理中断的过程中
  * 进程在操作系统内核程序临界区中（普通临界区可以，如打印机）
  * 原子操作过程中，如加锁，解锁，中断现场保护

* 常见调度算法：
  * 通用：FCFS，SJF，优先级调度算法（抢占式和非抢占式）
  * 主要用于作业调度：高响应比优先算法（响应比 = (作业等待时间 + 作业运行时间) / 作业运行时间）
  * 主要用于进程调度：RR（时间片轮转），多级反馈队列调度算法
* 由于 I/O 操作需要及时完成，一般 I/O 型作业优先级大于计算型作业

* 一次只允许一个进程使用的资源成为 **临界资源**，访问临界资源的那段代码称为 **临界区**
* 临界区互斥原则：空闲让进，忙则等待，有限等待，让权等待
* 实现临界区互斥的软件实现方法：单标志法（违背空闲让进），双标志先检验（违背忙则等待），双标志后检验（违背空闲让进，会导致饥饿）
* Peterson's Algorithm：用 flag 解决互斥，用 turn 解决饥饿

  ```cpp
  // 进程 i
  flag[i] = true; turn = j;
  while (flag[j] && turn==j);
  /*
   critical section;  // 临界区
  */
  flag[i] = false;  // 退出区
  /*
   remainder secton  // 剩余区
  */
  ```

  ```cpp
  // 进程 j
  flag[j] = true; turn = i;
  while (flag[i] && turn==i);
  /*
   critical section;  // 临界区
  */
  flag[j] = false;  // 退出区
  /*
   remainder secton  // 剩余区
  */
  ```

* 要对并发进程进行同步的原因：并发进程是异步的
* 共享程序段必须用可重入代码编写以实现共享的功能
* 死锁产生的必要条件：
  * 互斥条件
  * 不可剥夺条件
  * 请求保持条件
  * 循环等待条件
* 预防死锁：破坏四个必要条件中的一个或几个
* 死锁避免：防止进入不安全状态
* 安全状态：存在安全序列（P1, P2, ..., Pn) 使得每个进程都可以顺序地完成
* 死锁定理：S 为死锁 <=> S 的资源分配度不可完全简化
* 资源分配图：
  * 圆圈代表一个进程，框代表一类资源，框中的一个点代表一类资源中的一个资源
  * 请求边：进程 -> 资源
  * 分配边：资源 -> 进程
* 死锁产生的原因：
  * 时间上：进程运行中推进顺序不当
  * 空间上：对独占资源分配不当（资源不足只会造成“饥饿”）
* 系统不处于安全状态并不等于系统处于死锁状态，只有当进程提出资源请求，且全部进入阻塞状态时系统才处于死锁状态

## 内存管理

* 将用户源程序变为可在内存中执行的程序通常需要编译，链接，装入
* 覆盖与交换技术是在多道程序下用来扩充内存的两种方法，覆盖用于同一个进程，交换主要在不同进程或作页之间进行
* 动态分区分配：首次适应，最佳适应，最坏适应

* 多级页表中，顶级页表最多只有一个页面
* 页表项包含页框号，TLB 项包含页号和页框号，段表项包括段长和基址
* 编译后各目标模块采用的逻辑地址都是从 0 开始，只是相对于该模块的逻辑地址，链接阶段主要完成重定位，形成整个程序的完整逻辑地址空间
* 内存保护是内存管理的一部分，是操作系统的任务，但出于安全性和效率考虑必须由硬件实现，所以需要操作系统和硬件合作完成。
* 多进程的执行通过内存保护实现互不干扰
* 引入段式存储管理方式，主要是为了满足用户的下列要求：方便编程，分段共享，分段保护，动态链接，动态增长
* 系统提供给用户的物理地址空间大小为总的空间大小减去页表或段表的大小

* 请求分系统建立在基本分页系统基础之上，为了指出虚拟存储器功能而增加了请求调页功能和页面置换功能
* FIFO 算法可能出现 Belady 异常，LRU 和 OPT 不会出现
* 页面置换分配策略组合有：固定分别局部置换，可变分配全局置换，可变分配局部置换
* 虚拟存储器的最大容量是由计算机的地址结构确定的，与主存容量和外存容量没有必然的联系
* 在请求分页存储管理系统中，地址变换过程，可能会因地址越界，缺页，访问权限错误而产生中断
* 缺页中断与一般中断的区别：
  * 缺页中断在指令执行期间产生和处理中断信号，普通执行完后检查
  * 一条指令在执行期间可能产生多次缺页中断

## 文件管理

* 文件是有文件名的一组相关元素的集合，用户进行的输入，输出以文件为基本单位
* FCB 的有序集合称为文件目录，一个 FCB 就是一个文件目录项
* 文件目录也作为一个文件来处理，称为目录文件
* 采用索引结点（i 结点）的系统的目录项仅由文件名和指向相应索引结点的指针组成
* 硬链接：基于索引结点的共享方式，count 表示链接到本索引结点的目录项的的数目
* 软链接：基于符号链实现，系统创建一个 link 类型的文件，内容为链接文件的路径名
* 打开文件：将该文件的 FCB 复制到打开文件表（主存上），返回一个指针
* 文件的逻辑结构是用户组织数据的结构形式，物理结构是 OS 组织物理存储状态的结构形式

## I/O 管理

* I/O 系统层次结构：用户层 I/O 软件，设备独立性软件，设备驱动软件，中断处理程序
* 设备控制器中接口用来传输信号，I/O 逻辑用来实现对设备的控制
* 计算机系统为每台设备确定了一个编号以便区分和识别设备
* 磁盘高速缓冲区逻辑上属于磁盘，物理上则是驻留在内存中的盘块
* 缓冲区（Buffer）空了才能充入数据，满了才能把数据传出
* SPOOLing 技术的特点：将独占设备改造为共享设备，提高了 I/O 的速度，实现了虚拟设备的功能
* 输入/输出缓冲区在主存上，输入井和输出井在外存上
* 计算各种缓冲技术处理每块数据的时间的方法：假设一种初始状态，计算下一次到达相同状态所需要的时间
* 通道管理所涉及到的数据结构有：设备控制表，系统设备表，控制器控制表，通道控制表
